import argparse
import os
from PIL import Image

def convert_to_rgb565(r, g, b):
    """Converts an 8-bit RGB color to a 16-bit RGB565 value."""
    return ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3)

def process_image(input_path, output_path, display_width, display_height, var_name):
    """
    Resizes an image to fit within the display dimensions, converts it to
    RGB565 format, and generates a C header file.
    """
    try:
        img = Image.open(input_path)
    except IOError:
        print(f"Error: Cannot open image file '{input_path}'")
        return

    # 1. Resize the image while maintaining aspect ratio
    original_width, original_height = img.size
    ratio = min(display_width / original_width, display_height / original_height)
    
    new_width = int(original_width * ratio)
    new_height = int(original_height * ratio)

    print(f"Resizing image from {original_width}x{original_height} to {new_width}x{new_height}...")

    # Use LANCZOS for high-quality resizing
    try:
        # Pillow 9.1.0+
        resample_filter = Image.Resampling.LANCZOS
    except AttributeError:
        # Older Pillow
        resample_filter = Image.LANCZOS
        
    img_resized = img.resize((new_width, new_height), resample_filter)

    # Ensure the image is in RGB format (handles PNGs with alpha channels)
    img_rgb = img_resized.convert('RGB')

    # 2. Convert pixel data to a C array
    c_array = []
    for y in range(new_height):
        for x in range(new_width):
            r, g, b = img_rgb.getpixel((x, y))
            rgb565 = convert_to_rgb565(r, g, b)
            c_array.append(rgb565)

    # 3. Generate the C header file content
    with open(output_path, 'w') as f:
        header_guard = f"ASSET_{var_name.upper()}_H"
        f.write(f"// Generated by image_converter.py from '{os.path.basename(input_path)}'\n")
        f.write(f"#ifndef {header_guard}\n")
        f.write(f"#define {header_guard}\n\n")
        f.write('#include "pico/stdlib.h"\n\n')

        f.write(f"const uint16_t {var_name}_width = {new_width};\n")
        f.write(f"const uint16_t {var_name}_height = {new_height};\n\n")

        f.write(f"const uint16_t {var_name}_data[] = {{\n")
        
        # Write pixel data, formatted for readability
        pixels_per_line = 16
        for i, pixel in enumerate(c_array):
            if i % pixels_per_line == 0:
                f.write("    ")
            f.write(f"0x{pixel:04X}, ")
            if (i + 1) % pixels_per_line == 0:
                f.write("\n")
        
        if len(c_array) % pixels_per_line != 0:
            f.write("\n")
        f.write("};\n\n")
        f.write(f"#endif // {header_guard}\n")

    print(f"Successfully converted image to '{output_path}'")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Convert an image to a C header with RGB565 data.")
    parser.add_argument("input_file", help="Path to the input image file (e.g., my_icon.png).")
    parser.add_argument("output_file", help="Path for the output .h header file (e.g., src/weather_icon.h).")
    parser.add_argument("--width", type=int, default=320, help="Maximum width of the display area.")
    parser.add_argument("--height", type=int, default=240, help="Maximum height of the display area.")
    parser.add_argument("--var_name", help="C variable name for the asset (default: derived from output filename).")

    args = parser.parse_args()

    if not args.var_name:
        # Auto-generate a C-friendly variable name from the output filename
        base_name = os.path.basename(args.output_file)
        var_name = os.path.splitext(base_name)[0]
        var_name = ''.join(c if c.isalnum() else '_' for c in var_name)
    else:
        var_name = args.var_name

    process_image(args.input_file, args.output_file, args.width, args.height, var_name)